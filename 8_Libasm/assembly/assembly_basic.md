

# 1. 시작하기 앞서서



어셈블리어와 기계어는 1대1로 대응된다.

우리가 기존에 공부했던 C나 파이썬 같은 경우 프로그래밍 언어이고, 어셈블리어도 마찬가지이다.

하지만 C나 파이썬은 High Level 언어이다. 이는 인간이 이해하기 쉬운 언어라는 것이다.

반면에, 어셈블리어는 Low Level 언어로서 컴퓨터가 이해하기 쉬운 언어이다.



우리는 왜 어셈블리 언어를 배워야 할까?

1. 때때로 컴파일러가 생성한 코드보다 어셈블리어로 직접 쓴 코드가 훨씬 빠르고 작을 수 있다.
2. 어셈블리어를 통해 고급언어 사용시 힘들거나 불가능한 시스템 하드웨어의 직접적인 접근을 할 수 있다.
3. 어셈블리 언어를 공부함을 통해 컴퓨터의 작동원리를 파악할 수 있다.
4. 어셈블리 언어를 공부함으로서 컴파일러와 C와 같은 고급 언어가 어떻게 동작하는지 파악할 수 있다.



## 1.1 어셈블리어란?

어셈블리어를 처음 공부하는 사람들은 어셈블리어를 기계어에 가까운 언어 정도로만 알고 있을 것이다.

하지만 어셈블리 언어 프로그램은 고급  언어 프로그램처럼 문자 형태로 저장된다.

각각의 어셈블리 명령어들은 하나의 기계 명령에 대응된다.

`add 		eax, ebx`

에서 add 는 '덧셈을 한다'라는 명령어를 인간이 알기 쉬운 문자열로 대응 시킨 연상 기호 (mnemonic)이다.

어셈블리어의 일반적인 형식은

`mnmonic 		operand(s)` 과 같다.

어셈블러(Assembler)는 어셈블리 명령들로 작성된 파일을 읽어 들어서 기계어로 작성된 코드로 변환 해주는 프로그램이다. 컴파일러(Compiler)는 비슷한 작업을 하지만 고급언어를 기계어로 변환해주는 것이다.

CPU에 따라 기계어가 다르기 때문에 어셈블리어 또한 각각 다르다. 그렇기 때문에 각각의 컴퓨터 아키텍쳐에 따라서 코드를 포팅을 해주어야 한다. (반면에 C와 같은 고급언어는 컴파일만 잘 해주면 어떤 CPU에서든지 구동할 수 있다.)



## 1.2 피연산자

피연산자는 쉽게 이야기하면 명령어에서 연산을 당하는 대상이다.

`add		eax, ebx`를 예시로 들면, eax에 ebx를 더하는 명령어이고 피연산자는 eax와 ebx이다.

기계코드 명령들에 따라 피연산자의 형태와 개수가 다르다. 하지만 보통 0~3개의 피연산자를 가진다.

피연산자로는 다음과 같이 4가지가 올 수 있다.

- 레지스터 : 레지스터 피연산자를 통해 CPU 레지스터들에 직접적 접근이 가능하다.

  cpu에서 사용하는 변수로 생각하면 쉽다.

  - #### RAX (Accumulator Register)

    가장 많이 사용하는 레지스터, 더하기 빼기 같은 연산에 주로 사용된다.
    C에서 값을 return해줄 때, 그 return 해주는 값이 EAX에 저장된다.

  - #### RBX (Base Register)

    EAX와 마찬가지로 연산에 주로 사용되지만, return 값이 저장되지 않는다는 차이점이 있다.

  - #### RCX (Counter Register)

    카운트하는 레지스터, 예를 들어 C에서 for문을 사용할 때 하나씩 늘리는 인덱스의 역할을 수행.
    다만 차이점은, 우리는 하나씩 늘리는 대신 ECX는 갯수를 정해놓고 하나씩 하락시킨다.

  - #### RDX (Data Register)

    레지스터가 부족할 때 임시로 사용하는 레지스터

  - #### RSI (Source Index)

    데이터를 복사할 때, 소스데이터 즉 복사할 데이터의 주소가 저장된다.

  - #### RDI (Destination Index)

    데이터를 복사할 때, 목적 주소가 저장된다.

  - #### RSP (Stack Pointer)

    스택 프레임의 끝 주소 저장

  - #### RBP (Base Pointer)

    스택 프레임의 시작 주소 저장

  AX, BX, CX, DX는 모두 16비트 크기를 가지는 레지스터이다. 이후 32비트 크기를 가지는 아키텍쳐는 앞에 E를 붙히는 모양새가 된다. 또 64비트 아키텍쳐로 넘어오면서 앞에 R이 붙게 된다.



- 메모리 : 메모리에 저장된 데이터를 가르킨다. 이 때, 메모리의 주소값은 명령에 직접적으로 사용하거나, 레지스터에 저장하여 사용 가능하다. 언제나 세크먼트 최상단 부터의 오프셋 값으로 나타낸다.
- 즉시 피연산자(immediate) : 명령 자체에 있는 고정된 값들이다. 이들은 명령 자체에 저장된다.(즉, 데이터 세그먼트가 아닌 코드 세그먼트에 저장된다.)
- 묵시적 피연산자(implied) : 정확히 나타나지 않는다. 뒤에 나오는 INC 명령어는 idx++;와 같은 역할을 한다. (+ 1)이 생략되어 있는 것이다. 이 때 더해지는 1을 묵시적 피연산자라고 한다.



##### 세그먼트란?

세그먼트(Segment)는 프로그램에 정의된 특정 영역으로 코드, 데이터, 스택 등으로 알려져 있다.

이는 주기억 장치를 효율적으로 운영하기 위해서 일정한 크기, 대개로 64kb 크기의 논리적 단위로 나누어 할당과 할당 해제를 관리하는 것이고 이 논리적 단위를 세그먼트라고 한다.

즉, 프로그램 실행을 위해 필요한 공간, 데이터와 그 데이터를 처리하는 명령어를 위한 공간을 세그먼트 단위로 관리하는 것이다.

이를 위해 서로 관련이 있는 데이터를 저장하는 `데이터 세그먼트(Data Segment)`영역과 명령어를 저장하는 `코드 세그먼트(Code Segment)`영역으로 구분해서 사용한다.

또한 , 데이터 세그먼트 영역은 할당 방법에 따라 동적할당으로 관리되는 1.  `스택 세그먼트`, `힙 세그먼트`와 정적할당으로 관리되는 2. `데이터 세그먼트` 로 구분된다.

이렇게 구분되지는 데이터 세그먼트 영역에 데이터를 저장하기 위해 할당되어진 기억장소를 변수(variable)이라고 한다.

![스크린샷 2021-02-08 오후 4.04.43](/Users/Feldblume/Library/Application Support/typora-user-images/스크린샷 2021-02-08 오후 4.04.43.png)



## 1.3 기초 명령



#### PUSH, POP 명령

Stack에 값을 넣으면 push, stack에 있는 값을 가지고 오면 pop이다.



#### MOV 명령

특정한 지점의 데이터를 다른 지점으로 이동시킨다. (대입연산자와 비슷)

`mov 		dest, src`

src 에 있는 데이터가 dest로 복사된다. 이때, 두 피연산자가 모두 메모리이면 안된다.



`mov		 eax, 3 `  eax 레지스터에 3을 대입한다. (이 때 3은 즉시 피연산자)

`mov		 bx, ax ` ax 레지스터의 값을 bx 레지스터에 대입한다.



#### ADD 명령

두개의 정수를 더할 때 사용된다.

`add 		eax, 4`  eax = eax + 4

`add 		al, ah`  al = al + ah



#### SUB 명령

`sub 		bx, 10` bx = bx - 10

`sub 		ebx, edi` ebx = ebx - edi



#### INC와 DEC 명령

1을 증가 또는 감소 시키는 명령. 1이 묵시적 피연산자이므로 INC와 DEC의 기계 코드는 동일한 작업을 수행하는 ADD와 SUB의 기계코드의 크기보다 작다.

`inc 		ecx` ecx++

`dec 		dl` dl--



#### CMP 명령

`CMP		EAX, EDX` 

두 OPERAND를 비교하는 명령어



#### CALL, RET 명령

call - 함수를 호출하는 명령어

ret - call로 호출한 함수를 종료하고 call 다음의 명령줄로 이동하는 명령어



#### JMP 명령

피연산자의 위치로 실행 흐름이 변경된다. 피연산자가 가리키는 코드로 점프 뛰어서 실행한다고 생각하면 쉽다.



#### JNE 명령

[Jump If Not Equal]

위에서 cmp 한 결과가 같지 않으면, jmp 명령을 수행하는 것이다.



## 1.4 지시어

지시어는 CPU가 아니라 어셈블러를 위해 만들어진 것이다.

주로 어셈블러로 하여금 무언가를 하게 하거나 어셈블러에게 정보를 알려주는 역할을 한다. 지시어는 기계 코드로 변환되지 않는다.

주 용도는 :

- 상수를 정의한다.
- 데이터를 저장할 메모리를 정의한다.
- 메모리를 세그먼트로 묶는다.
- 조건적으로 소스코드를 포함시킨다.
- 다른 파일들을 포함시킨다.



#### equ 지시어

symbol(어셈블리 프로그래밍시 사용되는 상수)을 정의할 때 사용된다.

`symbol		equ (value)`

한 번 정의된 심볼의 값은 재정의 될 수 없다.



#### The % 정의 지시어

이 지시어는 C에서 #define과 비슷하다. C에서처럼 상수 매크로를 정의할 때 사용된다.

```assembly
%define SIZE 100
	mov		eax, SIZE
```

이 코드는 SIZE라는 이름의 매크로를 정의하고, 이를 MOV명령에서 사용하는 예시이다.

맥크로는 심볼과 다르게 재정의 될 수 있고 단순한 수가 아니어도 되기 때문에 심볼 보다 더 유연하다는 특징이 있다.



#### 데이터 지시어

데이터 지시어들은 데이터 세그먼트에서 메모리 상의 공간을 정의하는 데 사용된다.

메모리 공간이 정의되는 방법은 2가지이다.

1. `RES(X) 지시어`를 통해 오직 데이터를 위한 공간들만 정의
2. `D(X) 지시어`를 통해 초기의 값들을 위한 방들을 정의

각 지시어들 끝의 X에는 저장될 데이터의 크기를 나타내는 문자가 들어간다. 다음 표를 참조하자.

|   Unit    | Letter |
| :-------: | :----: |
|  바이트   |   B    |
|   워드    |   W    |
| 더블워드  |   D    |
| 쿼드워드  |   Q    |
| 10 바이트 |   T    |



메모리 위치는 대부분 다음과 같이 라벨로 표시한다.

```assembly
L1		db		0 ; L1으로 라벨 붙혀진 바이트가 0으로 초기화 됨
L2		dw		1000 ; L2로 라벨 붙혀진 워드가 1000으로 초기화 됨
L3		db		110101b ; L3로 라벨 붙혀진 바이트가 이진수 110101(53)로 초기화 됨
L4		db		12h ; L4로 라벨 붙혀진 바이트가 16진수 12로 초기화 됨
L5		db		17o ; L5로 라벨 붙혀진 바이트가 8진수 17로 초기화 됨
L6		dd		1A92h ; L6로 라벨 붙혀진 더블워드가 16진수 1A92로 초기화 됨
L7		resb	1 ; L7로 라벨 붙혀진 초기화 되지 않은 1 바이트
L8		db		"A" ; L8로 라벨 붙혀진 아스키 코드 A(65)로 초기화 됨
```



큰따옴표와 작은따옴표는 모두 같은 것으로 취급된다.

```assembly
L9		db		0, 1, 2, 3 ; 4바이트를 정의한다.
L10		db		"w", 'o', "r", 'd', 0 ; c문자열 "word"를 정의한다.
L11		db		'word', 0 ; L10과 같다.
```



DD지시어는 정수와 단일 정밀도 부동 소수점 상수들을 정의할 수 있다. 그러나 DQ의 경우 오직 2배 정밀도 부동 소수점 상수만 정의할 수 있다.

크기가 큰 것들을 위해서는 NASM의 TIMES 지시어를 이용할 수 있다. 이 지시어는 피연산자를 특정한 횟수 만큼 반복한다.

```assembly
L12		times		100 db 0 ; 100개의 (db 0)을 나열하는 것과 같다.
L13		resw		100 ; 100개의 워드를 위한 공간을 정의한다.
```



라벨에 대해서 더 알아보자.

라벨을 그냥 이용한다면 이는 데이터의 주소 (즉, 오프셋)으로 생각된다. 만약 라벨이 대괄호([])속에 사용된다면, 이는 그 주소에 위치한 데이터를 나타낸다. 다시 말해 라벨을 어떤 데이터에 대한 포인터라 하면, 대괄호는 C언어의 \*와 비슷한 역할을 하는 것이다.

```assembly
mov		al, [L1] ; al에 L1에 위치한 데이터를 대입한다.
mov		eax, L1 ; EAX = (L1에 위치한 바이트의 주소)
mov		[L1], ah ; L1에 위치한 바이트에 ah를 대입한다.
mov		eax, [L6] ; L6에 위치한 더블워를 EAX에 대입한다.
mov		al, [L6] ; L6에 위치한 더블워드의 하위 비트를 AL에 대입한다.
```

마지막 행 `mov		al, [L6]`을 보면 중요한 것을 알 수 있다.

어셈블러는 라벨이 어떠한 데이터를 가르키는지 신경쓰지 않는다. 모두 프로그래머에게 달려있는 것이다.



`mov		[L6], 1`는 오류를 발생한다.

어셈블러가 1을 바이트로 저장할지 워드로 저장할지, 더블워드로 저장할지 알 수 없기 때문이다. 따라서 이렇게 해줘야 한다.

`mov		dword [L6], 1` ; L6에 1을 저장한다.



## 1.5 입출력



입출력은 매우 시스템 종속적인 작업이다. 어셈블리어에서는 C와 같이 아리브러리가 제공되지 않기 때문에 직접적으로 하드웨어에 접근하거나 운영체제가 제공하는 저수준의 루틴을 이용해야 한다.

만약, pcasm 의 저자가 만든 I/O 루틴을 이용하고 싶다면 `%include "asm_io.inc"`와 같이 하면 된다.

![스크린샷 2021-02-08 오후 4.44.48](/Users/Feldblume/Library/Application Support/typora-user-images/스크린샷 2021-02-08 오후 4.44.48.png)





함수 호출규약